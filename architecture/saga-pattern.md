# Saga Pattern

### Saga Design Pattern

Micro Service 사이의 데이터 일관성을 관리하는 방법

각 서비스를 업데이트 한 뒤, 메시지 또는 이벤트를 게시하여 **다음 트랜잭션 단계를 트리거** 하는 트랜잭션 시퀀스

만약 한 서비스가 실패한다면 이전에 이어졌던 트랜잭션을 되돌리는 보상 트랜잭션을 실행 

### Transaction

트랜잭션. 논리 또는 작업의 단일 단위 (여러 작업으로 구성 가능)

**트랜잭션의 특징 : ACID**

단일 서비스 내의 트랜잭션읜 ACID이지만 서비스간 데이터 일관성을 위해서는 서비스간 트랜잭션 관리 전략이 요구된다.

단일 서비스가 아니라면? 다중 서비스 아키텍처에서의 전략

- **원자성** : 한 트랜잭션 내 [ 모든 이벤트가 발생하는 / 모든 이벤트가 발생하지 않는 ] 불가역적이고 돌이킬 수 없는 작업 집합
- **일관성** : 하나의 유효한 상태에서 다른 유효한 상태로만 데이터를 가져온다
- **격리** : 순차적으로 실행된 트랜잭션이 생성한 것과 동일한 테이터 상태를 생성하도록 보장
- **내구성** : 시스템 오류 or 물리적 사고에도 커밋된 트랜잭션이 커밋된 상태로 유지될 수 있도록 한다

### Saga Pattern

“로컬 트랜잭션” 시퀀스 사용해서 트랜잭션 관리를 제공

\* 로컬 트랜잭션 → ? 번역 보기

각 로컬 트랜잭션은 데이터베이스를 업데이트하고 메시지나 이벤트를 게시하여 사가에서 다음 로컬 트랜잭션을 트리거한다

로컬 트랜잭션이 실패하면 사가는 이전 로컬 트랜잭션에 의해 변경된 내용을 “실행 취소”하는 일련의 보상 트랜잭션 실행

**보상 가능한 트랜잭션** : 반대 효과를 가진 다른 트랜잭션을 처리하여 잠재적으로 되돌릴 수 있는 트랜잭션

**피봇 트랜잭션** : 보상할 수 없거나 다시 시도할 수 없는 트랜잭션, 또는 마지막 보상 가능한 트랜잭션이거나 사가에서 첫 번째 재시도 가능한 트랜잭션일 수도 있다

**다시 시도 가능한 트랜잭션** : 피봇 트랜잭션을 따르는 트랜잭션이며 성공을 보장

### 사가 구현 방법

- *choreography*
  - 중앙 집중식 제어 없이 자신이 보유한 로컬 트랜잭션을 관리하며, 트랜잭션이 종료되면 완료 이벤트를 발생시킨다
  - 그 다음에 수행되어야 할 트랜잭션이 있다면, 해당 트랜잭션을 수행해야 하는 App에서 완료 이벤트를 수신받고 다음 작업을 처리한다
  - 구축은 쉬우나 운영 입장에서는 트랜잭션 현재 상태를 알기 힘들다
- *orchestration*
  - 트랜잭션 처리를 위한 saga 인스턴스가 별도로 존재
  - 트랜잭션에 관여하는 모든 app은 매니저에 의해 점진적으로 트랜잭션을 수행하며 결과를 매니저에게 전달
  - 만약 중간에 실패하게 되면 매니저에서 보상 트랜잭션을 발동하여 일관성을 유지