# Kubernetes

<br>



### Kubernetes

- 컨테이너 운영을 자동화하기 위한 컨테이너 오케스트레이션 도구
- 많은 수의 컨테이너를 협조적으로 연동시키기 위한 통합 시스템
- 컨테이너를 이용한 애플리케이션 배포 외에도 다양한 운영 관리 업무를 자동화할 수 있다
  - 도커 호스트 관리, 서버 리소스의 여유를 고려한 컨테이너 배치, 스케일링, 여러 개의 컨테이너 그룹에 대한 로드 밸런싱, 헬스 체크 등의 기능을 갖춤

<br>



##### 클라우드 플랫폼의 쿠버네티스 지원 

- 주 개발인 GCP의 GKE(Google Kubernetes Engine)이란 컨테이너 매니지드 서비스 뿐만 아니라 다양한 쿠버네티스 매니지드 서비스가 있다
  - AWS의 EKS
  - AZURE의 AKS
- 쿠버네티스를 클라우드 플랫폼에 심리스하게 연동시켜 개발을 효율적으로 수행할 수 있는 서비스를 제공하는 것이 클라우드 플랫폼의 필수 경쟁력이 되었다

##### 도커에 정식 통합

- 2017년 10월 도커와 쿠버네티스 통합 정식 발표
- 도커 데스크톱에서 쿠버네티스 클러스터를 구축하는 기능이 새로 발표

<br>



#### 쿠버네티스의 역할

도커 : 컨테이너를 관리하는 데몬 `dockerd`와 명령행 도구로 구성

쿠버네티스 : 여러 대의 호스트를 묶어 기초적인 컨테이너 오케스트레이션 기능 제공 + 도커 비롯 여러 가지 컨테이너 런타임을 다룰 수 있다

<br>

### 쿠버네티스의 주요 개념
> 쿠버네티스로 실행하는 애플리케이션은 애플리케이션을 구성하는 다양한 리소스가 함께 연동해 동작 <br>
> \* 쿠버네티스 리소스 : 애플리케이션을 구성하는 부품 (ex) 노드, 네임스페이스, 파드 등

<br>

#### 쿠버네티스 리소스 종류
- 노드 : 컨테이너가 배치되는 대상 서버
- 네임스페이스 : 쿠버네티스 클러스터 안의 가상 클러스터
- 파드 : 컨테이너의 집합 중 **가장 작은 단위**, 컨테이너의 실행 방법을 정의
- 레플리카 세트 : *같은 스펙을 갖는 파드*를 여러 개 생성하고 관리하는 역할
- 디플로이먼트 : 레플리카 세트의 리비전을 관리
- 서비스 : 파드의 집합에 접근하기 위한 경로를 정의
- 인그레스 : 서비스를 쿠버네티스 클러스터 외부로 노출
- 컨피그 맵 : **설정 정보를 정의**하고 파드에 전달
- 퍼시스턴스 볼륨 : **파드가 사용할 스토리지**의 크기 밎 종류
- 퍼시스턴스 볼륨 클레임 : 퍼시스턴스 볼륨을 동적으로 확보
- 스토리지 클래스 : **퍼시스턴스 볼륨이 확보하는 스토리지**의 종류
- 스테이트풀 세트 : 같은 스펙으로 모두 동일한 파드를 여러 개 생성하고 관리
- 잡 : 상주 실행을 목적으로 하지 않는 파드를 여러 개 생성하고 정상적인 종료를 보장
- 크론잡 : 크론 문법으로 스케줄링되는 잡
- 시크릿 : 인증 정보 같은 기밀 데이터를 정의
- 롤 : 네임스페이스 안에서 조작 가능한 쿠버네티스 리소스의 규칙을 정의
- 롤 바인딩 : 쿠버네티스 리소스 사용자와 롤을 연결 짓는다
- 클러스터 롤 바인딩 : 쿠버네티스 리소스 사용자와 클러스터 롤을 연결짓는다
- 서비스 계정 : 파드가 쿠버네티스 리소스를 조작할 때 사용하는 계정

<br>

> ❔ 레플리카 세트 vs 스테이트풀 세트 (정확한 차이 비교해보기)
> - 같은 스펙**의** 파드 여러 개 생성 vs 같은 스펙**으로** 모두 동일한 파드 여러 개 생성 

<br>



#### 쿠버네티스 클러스터와 노드
쿠버네티스 클러스터 : 쿠버네티스의 여러 리소스를 관리하기 위한 집합체
- 쿠버네티스 리소스 중 가장 큰 개념 -> 노드
- 노드 : 쿠버네티스 클러스터의 관리 대상으로 등록된 도커 호스트
  - 쿠버네티스 클러스터 전체를 관리하는 마스터 노드 서버가 적어도 하나 이상 존재
  - 마스터와 노드의 그룹으로 쿠버네티스 클러스터 존재
- '클러스터에 배치된 노드의 수, 노드의 사양 등'에 의해 배치할 컨테이너 수 결정
<br>

> ⌨ 현재 클러스터에 소속된 노드 목록 확인
> ```shell
> $ kubectl get nodes  
> ```

<br>



> ##### 마스터 서버를 구성하는 관리 컴포넌트 종류
> - kube-apiserver : 쿠버네티스 API를 노출하는 컴포넌트 kubectl로부터 리소스를 조작 명령 받음
> - etcd : 고가용성을 갖춘 분산 key-value 스토어, 쿠버네티스 클러스터의 백킹 스토어로 사용
> - kube-scheduler : 노드 모니터링, 컨테이너를 배치할 적절한 노드 선택
> - kube-controller-manager : 리소스를 제어하는 컨트롤러를 실행

<br>



#### 네임스페이스

쿠버네티스 클러스터 안에 만드는 가상 클러스터
- 처음에 기본으로 존재하는 네임스페이스 4개 : `default`, `docker`, `kube-public`, `kube-system`
- 네임스페이스별로 권한 제어가 가능
<br>

> ⌨ 현재 클러스터 안에 존재하는 네임스페이스 목록 확인
> ```shell
> $ kubectl get namespace
> ```

<br>



#### 파드
컨테이너가 모인 집합체의 단위 (최소 1개 이상의 컨테이너)
- 서로 결합이 강하다면, 해당 컨테이너들을 파드로 묶어 일괄 배포하는 쪽이 더 나은 경우도 있다
- 단, 한 파드 안의 컨테이너들은 모두 같은 노드에 배치해야 한다 
<br>

:peach: **파드 생성 및 배포**

**파드 생성**

- `kubectl` 명령어로도 파드 생성이 되지만, 버전 관리 관점에서 yaml 파일 정의를 추천
- 매니페스트 파일 -> 쿠버네티스의 여러 가지 리소스를 정의하는 파일

![](C:\Users\kbeey\Documents\workspace-git\today-i-learned\TIL\container\pod-yaml.jpg)

<br>



**파드 배포**

> ⌨ 매니페스트 파일을 로컬 쿠버네티스 클러스터에 배포
>
> ```shell
> $ kubectl apply -f pod.yaml
> pod "pod" created
> ```
>
> - `-f` : 매니페스트 파일에 대한 경로를 지정

<br>



:peach: **파드 조작**



> ⌨ 목록을 조회해서 파드 상태 확인
>
> ```shell
> $ kubectl get pod
> NAME	READY	STATUS	RESTARTS	AGE
> sample-echo 2/2 Running	011m
> ```
>
> - READY :`2/2` -> `실행 상태의 컨테이너 수/파드에 정의된 컨테이너 수`
> - STATUS : Running -> 파드 안의 모든 컨테이너가 실행 중

<br>



> ⌨ kubectl을 사용해 컨테이너 안에 접근
>
> ```shell
> $ kubectl exec -it sample-echo sh -c nginx
> #
> ```
>
> - `-c` : 컨테이너 명 지정

<br>



> ⌨ 파드 안에 있는 컨테이너의 표준 출력을 화면에 출력
>
> ```shell
> $ kubectl logs -f sample-echo -c echo
> 2022/01/15 12:14:02 start server
> ```

<br>



> ⌨  파드( 또는 리소스 역시 ) 삭제 
>
> ```shell
> $ kubectl delete pod sample-echo
> ```

<br>



> ⌨  매니페스트 파일로 파드 삭제 (매니페스트에 작성된 리소스 전체가 삭제) 
>
> ```shell
> $ kubectl delete -f pod.yaml
> ```

<br>



<br>



#### 레플리카세트

kind를 파드로 정의한 매니페스트 파일로는 파드를 하나밖에 생성할 수 없다

어느 정도 규모가 있는 애플리케이션을 구축하려면 같은 파드를 여러 개 실행해 가용성을 확보해야 하는 경우가 생긴다

**레플리카세트** : 똑같은 정의를 갖는 파드를 여러 개 생성하고 관리하기 위한 리소스

```yaml
apiVersion: apps/v1
kind: ReplicaSet
metadata:
	name: echo
	labels:
		app: echo
spec:
	replicas: 3		# 레플리카세트에서 만들 파드의 복제본 수
	selector:
		matchLabels:
			app: echo
        template: # template 하단에 pod 리소스 정의
        	metadata:
        		labels:
        			app: echo
            spec:
            	containers:
            	- name: nginx
            	  image: image-path/nginx:latest
            	  env:
            	  - name: BACKEND_HOST
            	    value: localhost:8080
            	  ports:
            	  - containerPort: 80
            	- name: echo
            	  image: image-path:echo:latest
            	  ports:
            	  - containerPort: 8080
```

매니페스트 정의에 따라 파드를 replicas에서 지정한 수만큼 만들어 파드 정의 및 파드 복제를 모두 수행

\* 같은 파드가 여럿 복제된 것이므로 파드명에 [`파드명`+`무작위 생성 접미사`]로 작명된다

<br>



> ⌨ 생성한 레플리카세트를 매니페스트 파일을 이용해 삭제  
>
> ```shell
> $ kubectl delete -f sample-replicaset.yaml  # 관련 파드가 모두 삭제
> ```

<br>



<br>



#### 디플로이먼트

레플리카세트보다 상위에 해당하는 리소스. 

**디플로이먼트(deployment)** : 애플리케이션 배포(deploy)의 기본 단위가 되는 리소스

> vs 리플리카세트 
>
> - 똑같은 파드의 레플리케이션 개수를 관리 및 제어하는 리소스인데 비해. 디플로이먼트는 레플리카세트를 관리하고 다루기 위한 리소스

- 디플로이먼트의 정의와 레플리카세트의 정의가 크게 다르지는 않다 -> **디플로이먼트가 레플리카세트의 리비전 관리를 할 수 있다는 차이**

<br>



> ⌨ 어떤 kubectl 명령을 실행했는지 기록을 남기는 옵션 `--record`를 붙여 kubectl로 클러스터에 반영
>
> ```shell
> $ kubrctl apply -f sample-deployment.yaml --record
> ```

<br>



> ⌨ 상태 확인
>
> ```shell
> $ kubrctl get pod, replicaset, deployment --selector app=echo
> ```

<br>



> ⌨ 리비전 확인
>
> ```shell
> $ kubrctl rollout history deployment echo
> ```
>

<br>



#### 레플리카세트의 생애주기

- 쿠버네티스는 디플로이먼트를 단위로 애플리케이션을 배포 
  -> 실제 운영에서는 레플리카세트를 직접 다루기보다는 디플로이먼트 매니페스트 파일을 통해 다루는 경우가 대부분
- 디플로이먼트가 관리하는 레플리카세트
  - 지정된 개수만큼 파드를 확보
  - 파드를 새로운 버전으로 교체
  - 이전 버전으로 롤백 하는 등의 역할
- 디플로이먼트를 수정하면 레플리카세트가 새로 생성되고 기존 레플리카세트와 교체된다

:peach: **새 레플리카세트가 생성되는 경우**

- :question: 파드 개수만 수정한다면? 레플리카세트가 새로 생성되지 않음
-  :question: 컨테이너 이미지가 수정됐다면? 디플로이먼트의 새 리비전 -> 레플리카세트 생성 완료

:peach: **롤백 실행**

- 디플로이먼트는 리비전 번호로 기록되므로 특정 리비전의 내용 확인 가능

> ⌨  특정 리비전의 내용 확인 가능
>
> ```shell
> $ kubectl rollout history deployment echo --revision=1
> ```
>
> ⌨  바로 직전 리비전으로 롤백
>
> ```shell
> $ kubectl rollout undo deployment echo
> ```

<br>



#### 서비스

- 쿠버네티스 클러스터 안에서 파드의 집합(주로 레플리카세트)에 대한 경로나 서비스 디스커버리를 제공하는 리소스
- 서비스의 대상이 되는 파드는 서비스에서 정의하느 레이블 셀렉터로 정해진다
- 

<br>



----



> ⌨ 
>
> ```shell
> $ 
> ```

<br>

