# Chapter 02 리눅스의 설치

<br>

## 🍀 02 파티션 (Partition)

<br>

#### 파티션의 특징과 종류 

- 파티션 : 하나의 물리적 디스크를 여러 개의 논리적인 디스크로 분할하는 것

- 다중 파티션의 장점

  - 파티션마다 독립적인 파일 시스템이 운영되기 때문에 파일 점검 시간이 줄어든다 -> 부팅 속도 빠름
  - 한 파티션 파일 시스템이 손상되더라도, 다른 파티션에 영향을 주지 않는다 -> 안정성 높음
  - 필요한 파티션만 포맷 가능 -> 백업 & 업그레이드 간편

- `/proc/partitions` : 파티션의 상태 정보를 확인할 수 있는 파일 

- ##### 파티션 구분

  1. ##### 주 파티션 Primary Partition

     - 부팅이 가능한 **기본 파티션**
     - 1개 하드디스크 당 **최대 4개의 주 파티션 분할 가능**
       - *4개 이상 사용할 경우, 확장 파티션 안 여러 논리 파티션으로 분할해 데이터 저장* 

  2. ##### 확장 파티션 Extended Partition 

     - **주 파티션 내부**에 생성
     - 데이터 저장 영역을 위한 것이 아니라 논리 파티션을 생성하기 위한 역할
     - 1~4번 번호가 붙여짐

  3. ##### 논리 파티션 Logical Partition

     - 확장 파티션 안에 생성되는 파티션
     - 논리 파티션은 12개 이상 생성하지 않는 것을 권고. 5번 이후의 번호가 붙여짐 

  4. ##### 스왑 파티션 Swap Partition

     - 하드디스크의 일부를 **메모리처럼 사용하는 영역**
     - 주 파티션 or 논리 파티션에 생성
     - 프로그램 실행 시 부족한 메모리 용량을 하드디스크로 대신함
     - 리눅스 설치 시 반드시 설치해야하는 영역
     - swap 영역의 크기는 메모리의 2배로 설정하도록 권고
  
- [파티션 설명 참고 1](https://jaypan.tistory.com/6)

- [파티션 설명 참고 2](https://btyy.tistory.com/entry/LINUX-21%EC%9D%BC%EC%B0%A8-CentOS-%ED%8C%8C%ED%8B%B0%EC%85%98%EC%A3%BC-%ED%8C%8C%ED%8B%B0%EC%85%98%ED%99%95%EC%9E%A5-%ED%8C%8C%ED%8B%B0%EC%85%98-%EB%85%BC%EB%A6%AC-%ED%8C%8C%ED%8B%B0%EC%85%98-%EB%94%94%EC%8A%A4%ED%81%AC-%EA%B4%80%EB%A6%AC%ED%8C%8C%ED%8B%B0%EC%85%98-%EB%AA%85%EB%A0%B9%EC%96%B4fdisk-%ED%8C%8C%EC%9D%BC%EC%8B%9C%EC%8A%A4%ED%85%9Cmkfs)

- [하드웨어 개념 정리](https://m.blog.naver.com/PostView.nhn?blogId=bestheroz&logNo=66675774&proxyReferer=https:%2F%2Fwww.google.com%2F)

---

<br>

#### 파일 시스템

- 파일 시스템 : 운영체제가 **파일을 시스템의 디스크 파티션상에 구성하는 방식**
- **일정한 규칙**을 가지고 파일을 저장하도록 규칙방식 제시
- 파티션에 파일 시스템이 없으면, 파일 시스템 생성 후 사용 가능
- 리눅스 고유 파일 시스템 뿐만이 아닌 다양한 파일 시스템 지원

<br>

---

<br>

#### LVM (Logical Volume Manager)

<img src="https://www.redhat.com/sysadmin/sites/default/files/styles/embed_small/public/2020-03/basic-lvm-volume_0.png?itok=5pWKbDm0" style="zoom: 33%; float:left;" >

- **여러 개의 하드디스크를 합쳐** 사용하는 기술로 한 개의 파일 시스템을 사용
- 작은 용량의 하드디스크 여러 개를 -> 큰 용량의 하드디스크 한 개처럼 사용
  - 다수의 디스크를 묶어서 사용함으로써 파티션의 크기를 줄이거나 늘릴 수 있다

| 물리 볼륨 Physical Volume    | 여러 개의 물리적 하드디스크                        |
| ---------------------------- | -------------------------------------------------- |
| **볼륨 그룹 Volume Group**   | 물리 볼륨을 **합쳐 하나의 물리적인 그룹**으로 만듦 |
| **논리 볼륨 Logical Volume** | 볼륨 그룹을 나눠서 **다수의 논리 그룹으로 만듦**   |

<br>

---

<br>

#### RAID

- 복수 배열 독립 디스크 (**R**edundant **A**rray of **I**ndependent **D**isks)
- 여러 개의 물리적 디스크를 하나의 논리적 디스크로 인식하여 작동하게 하는 기술
- 여러 개의 하드디스크에 일부 중복된 데이터를 나눠서 저장하는 기술

- ##### RAID 종류

  - ##### 하드웨어 RAID

    - 하드웨어 제조업체에서 여러 개의 하드디스크를 장비로 만들어 그 자체를 공급
    - 안정적일수록 고가

  - ##### 소프트웨어 RAID

    - 고가의 하드웨어 RAID의 대안책
    - 운영체제에서 지원하는 방식
    - 저렴한 비용으로 안전한 데이터 저장 가능

- **레벨** : 데이터를 저장하는 다양한 방법들

  - *레벨에 따라 저장 장치의 신뢰성을 높이거나 전체 성능을 향상시키는 등 다양한 목적*

  |        |                                                              |                                                              |
  | ------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | RAID 0 | <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/9b/RAID_0.svg/150px-RAID_0.svg.png"> | **스트라이핑 저장 방식**<br />: 연속된 데이터를 여러 디스크에 나눠 저장<br /><br />최소 2개 이상의 하드디스크 요구<br />입출력 작업을 **모든 디스크에 동시에 진행** -> 하나의 디스크라도 고장나면 전체에 영향<br />**고장 대비 능력이 없어서 주요 데이터 저장엔 부적합** |
  | RAID 1 | <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/b7/RAID_1.svg/150px-RAID_1.svg.png"> | **미러링 방식**<br />: 하나의 디스크에 저장하는 데이터를 **다른 디스크에 동일하게 백업** 저장<br /><br />데이터 저장 시 **두 배의 용량** 필요 <br />결합 허용을 제공하지만 공간 효율성이 떨어짐<br />**주요한 데이터를 저장**할 때 적절 |
  | RAID 2 | <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/b5/RAID2_arch.svg/350px-RAID2_arch.svg.png"> | **스트라이핑 저장 방식**<br /><br />기록용과 데이터 복구용 디스크를 별도로 제공<br />**오류 제어 기능이 없는 디스크를 위해** 해밍 코드 사용<br />디스크의 사용 효율성 낮음<br />**모든 SCSI 디스크에 ECC(에러 검출 기능) 탑재**하고 있기 때문에 **현재는 사용되지 않는 구성**<br /> |
  | RAID 3 | <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/f9/RAID_3.svg/300px-RAID_3.svg.png"> | **스트라이핑 저장 방식**<br /><br />오류 검출을 위해 패리티 방식 이용<br />패리티 정보를 저장하기 위해 전용 디스크를 사용<br /> -> `스트라이핑 저장용` 최소 2개 + `패리티 저장용` 최소 1개<br />데이터 복구는 패리티 저장 디스크에 기록된 정보의 XOR을 계산하여 수행<br />대형 레코드가 사용되는 단일 사용자 시스템에 적합 |
  | RAID 4 | <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/ad/RAID_4.svg/300px-RAID_4.svg.png"> | RAID 3과 유사한 방식 -> `스트라이핑 저장용` 최소 2개 + `패리티 저장용` 최소 1개<br /><br />RAID 3과 차이점 <br />: 3은 Byte 단위로 데이터를 저장하는 반면, 4는 Block(섹터) 단위로 저장 |
  | RAID 5 | <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/64/RAID_5.svg/300px-RAID_5.svg.png"> | **스트라이핑 저장 방식**<br /><br />**디스크마다 패리티 정보**를 갖고 있어 **패리티 디스크의 병목현상을 줄이는 것이 가능**해 실무에서 주로 사용<br />디스크 섹터 단위로 저장<br />쓰기 작업이 많지 않은 **다중 사용자 시스템에 적합** |
  | RAID 6 | <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/70/RAID_6.svg/300px-RAID_6.svg.png"> | **RAID 5를 확장한 것**<br /><br />제 2 패리티를 두는 `dual parity`를 사용함으로써 더 나은 **무정지성**을 가짐<br />최소 4개의 드라이브 요구 |

  - [RAID 참고](https://zetastring.tistory.com/121)

<br>

#### 파티션 분할

- ##### fdisk 

  - 파티션 테이블을 관리하는 명령어

  - 리눅스의 디스크 파티션을 생성, 수정, 삭제할 수 있는 일종의 유틸리티

  - ##### fdisk 명령어

    | 명령어 | 설명                                                      |
    | ------ | --------------------------------------------------------- |
    | a      | 부팅 파티션 지정                                          |
    | l      | 파티션 종류 선택 시, 리눅스에서 지원하는 파티션 목록 확인 |
    | n      | 새로운 파티션 추가                                        |
    | t      | 파티션 종류 변경                                          |
    | w      | 파티션 정보 저장                                          |
    | p      | 파티션 정보 확인                                          |
    | q      | 작업 종료                                                 |

<br>

## 🍀 03 부트 매니저 (Boot Manager)

<br>

#### 부트로더 (boot loader)

- 부트스트랩 로더의 줄임말

- 컴퓨터를 사용자가 사용할 수 있도록 디스크나 플래시에 저장된 운영체제를 읽어 주기억장치에 적제해 주는 프로그램

- 운영체제가 시동되기 이전에 미리 실행되면서 커널이 올바르게 시동되기 위해 필요한 모든 관련 작업을 마무리하고 **최종적으로 운영체제를 시동시키기 위한 프로그램**

- 임베디드 시스템 부트로더 : PC의 BIOS와 OS Loader의 기능을 수행하는 프로그램. 시스템이 부팅할 때 가장 먼저 수행

- 운영체제 실행에 필요한 환경을 설정, 운영체제 이미지를 메모리에 복사

- 부트 매니저라고도 부르며 크기가 512바이트로 하드디스크의 첫 번째 섹터인 **MBR(Master Boot Record)**에 위치

  - **MBR(Master Boot Record)** : 부트 매니저 프로그램과 파티션 정보를 저장

    <img src="https://static.javatpoint.com/operating-system/images/os-master-boot-record.png">

- 주 파티션마다 부트 섹터가 할당된다

  - 부트 섹터 : 디스크의 다른 부분에 저장되는 부팅 프로그램을 담을 수 있는 하드디스크, 플로피 디스크 또는 비슷한 기억 장치의 섹터

- 분할된 주 파티션들은 자신의 부트 레코드를 MBR에 기록하여 실행

- 한 컴퓨터에 다수의 운영체제가 설치되어 있을 경우 작업 운영체제를 선택하여 부팅할 수 있도록 한다

  - x86 아키텍처에서 많이 사용되는 부트로더 종류

    - ###### LILO (LInux LOader) : 리눅스 운영체제에 한정

    - ###### GRUB (GRand Unified Bootloader) : 다른 운영체제에서도 사용 가능

      - 둘 다 System 전원이 공급되면 가장 먼저 ROM-BIOS에서 시스템 제어권을 가지고 장착된 하드웨어에 대한 기본적인 점검과 인식을 한다
      - ROM-BIOS는 하드디스크의 첫 번째 부트 섹터인 MBR에 있는 부트로더에게 제어권을 넘김

##### GRUB (GRand Unified Bootloader)

- Erich Stefan Boleny에 의해 개발된 부트로더

- 리눅스의 전통적인 부트로더로 사용해왔던 LILO의 단점 보완 -> 개선점 : 설정 및 사용이 편리

- 부트 정보를 사용자가 임의로 변경해 부팅 가능. 부트 정보가 올바르지 않더라도 부팅시 **바로 수정 가능**

- 다른 운영체제와 멀티부팅 가능

- 대화형 설정이므로 커널의 경로와 파일 이름만 알면 부팅 가능

  -  *.**파일 시스템과 커널 실행 포맷을 인식하여** 하드디스크 상에서 커널의 물리적 위치를 기록하지 않아도 커널의 위치와 커널 이미지 파일명만 알고있으면 부팅 가능*

- 메뉴 인터페이스 환경을 지원하며 대화명 모드로 부트 정보를 설정할 수 있다

- ##### GRUB 환경 설정 파일

  - `/boot/grub/grub.conf` or `/etc/grub.conf`

    - root(hd0, 0) : ( -> primary master의 첫 번째 파티션 의미) root 파티션 위치 지정

    - `kernel/boot/vmlinuz` : 부팅하면서 메모리에 위치하는 리눅스 커널에 전달할 인수를 지정하는 옵션

      \* /boot 파티션을 별도로 사용 중이라면 커널의 위치는 `kernel/boot/vm`

- ##### GRUB 장치명

  - ROM-BIOS에서 사용하는 정보를 사용하며 IDE, SCSI 장치명을 별도로 구분짓지 않는다
  - (디스크장치명, 파티션명) 형식 표기하되 번호는 0부터 시작

<br>

#### 런 레벨 (run level)

- 리눅스 부팅 시 런 레벨에 따라 작동하는 서비스들을 조정 가능
- **리눅스 부팅의 마지막 단계**에서 **모든 프로세스의 부모 프로세스인 init이 생성**
- 런레벨 : 프로세스 init이 수행해야할 일련의 처리 방법 (0 ~ 6)

<br>

#### 로그인과 로그아웃

##### 로그인

- X 윈도우상에서의 로그인/아웃과 콘솔상에서 로그인/아웃이 있다
- 로그인 과정
  1. 입력한 패스워드와 `/etc/passwd` 필드를 비교
  2. 셸 설정 파일 실행
     - 셸 설정 파일이 수행하는 일 
       - 검색 경로 설정
       - 터미널 종류 설정 및 다양한 터미널 설정
       - 환경변수 설정
       - 로그인 시 실행 명령어 실행
       - 로그인 메시지 출력
  3. 로그인 셸 실행
     - 로그인 셸은 `/etc/passwd`의 마지막 필드에 정의되어 있다
     - 로그인 셸에 따라 프롬프트가 다름

##### 로그아웃

- 관리자는 일정 시간 동안 작업을 수행하지 않는 모든 사용자들을 **강제로 로그아웃**할 수 있다
  - `/etc/profile`에 TMOUT 변수 값 지정해 작업 수행

