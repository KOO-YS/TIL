

# 기술 면접 준비 01

> ##### 기술 면접 준비를 위한 자료 조사



## 운영체제

- #### PCB 와 Process의 5가지 상태. context switching이 무엇인가?

  [PCB 위키 정보](http://itwiki.kr/w/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EC%A0%9C%EC%96%B4_%EB%B8%94%EB%A1%9D)

  **Process**

  - PCB를 가지고 있다
  - 현재 실행 중이거나 곧 실행 가능하며 CPU를 할당받을 수 있는 프로그램
  - 주기억장치에 올라가 있는 프로그램
  - 상태 5가지
    - 생성 (New) : 프로세스 갓 생성
    - 준비 (Ready) : CPU에 의해 실행되기 위해 대기하는 상태
    - 실행 (Run) : 프로세스에 포함된 명령어가 실행되는 상태
    - 대기 (Wait) : 보류. 프로세스가 특정 이벤트를 기다리는 상태
    - 종료 (Terminated) : 프로세스 종료

  **PCB (Process Control Block : 프로세스 제어 블록)**

  - 현재 실행중인 프로세스의 모든 상태 정보를 담고있는 자료구조 테이블/ 저장장소
  - 실행중인 프로세스는 모두 PCB를 가진다 -> 제어하기위해
  - 프로세스 수행이 완료되면 PCB도 삭제된다
  - PCB 포함 정보
    - 프로세스 고유번호 (PID)
    - 포인터 : 다음 실행될 프로세스의 포인터
    - 레지스터 저장 영역 : 레지스터 관련 정보
    - 프로세스 현재 상태 : 준비, 대기, 실행...
    - 프로세스 우선 순위 : 스케줄링 프로세스 우선순위
    - 프로세스 할당 메모리 정보
    - ...

  **Process Context Switching (문맥교환)**

  - 하나의 프로세스가  CPU를 사용중인 상태에서 다른 프로세스가 CPU를 사용하도록 하기 위해 이전 프로세스의 상태를 PCB에 보관하고 바뀔 프로세스 PCB를 읽어 레지스터에 적재하는 과정이다
  - 인터럽트로 인해 발생 : 하드웨어나 예외상황 발생으로 처리가 필요한 경우
  - OS스케줄러가 문맥교환을  하는 중 다른 작업을 할 수 없기 때문에 `오버헤드`라고 부름
    - 문맥교환 중 아무것도 할수 없기 때문에 잦은 문맥교환은 효율이 떨어진다

  

  ---

- #### 페이지 교체 알고리즘 중  FIFO가 무엇이며 FIFO이외에 본인이 가장 효율적이라고 생각하는 교체방식은 무엇인가?

  [페이지 교체 알고리즘 참고](https://kim6394.tistory.com/203)

  **페이지 교체 알고리즘**

  - 페이지를 할당할 때 어떤 페이지로 교체할지 결정하는 방법
  - 쉬운 이해와 간단한 설계
  - 벨레이디의 모순현상 발생

  **FIFO (First In First Out)**

  - 메모리에 올라온지 가장 오래된 페이지를 먼저 내보낸다

  **OTP (Optimal replacement, 최적교체)**

  - 앞으로 가장 오랫동안 사용하지 않을 페이지 우선 교체
  - 벨레이디 제안
  - 실질적으로 페이지가 앞으로 잘 사용되지 않을 것이라는 보장이 없다

  **LRU (Least-Recently-Used)**

  - 최근에 사용하지 않은 페이지를 가장 먼저 내보낸다
  - 과거를 보고 판단하므로 실질적 사용이 가능한 알고리즘





## 네트워크

- #### HTTP Protocol 의 요청 응답 메시지 구조는 어떠한 방식으로 구성되어 있는가?

  [HTTP 메시지 구조 예시 설명](https://juyoung-1008.tistory.com/9)
  
  [HTTP 메시지 구조](https://ychae-leah.tistory.com/82)
  
  [이해 돕기](https://dororongju.tistory.com/48)

**HTTP 프로토콜 (Hypertext Transfer Protocol)**

  - 클라이언트 -  서버간 프로토콜
  - TCP/IP 프로토콜 위에서 동작하므로 서버와 클라이언트는 각각 TCP/IP 동작에 필수적인 IP 주소를 가져야한다
  - 요청은 클라이언트에서, 응답은 서버에서 주로 이루어진다



- ##### HTTP 요청

| 요청라인       | GET / HTTP/ 1.1    (Method/보낼 URL/HTTP Version)            |
| -------------- | ------------------------------------------------------------ |
| HTTP 헤더 정보 | HTTP 요청 그 자체에 대한 정보를 담고있다.                    |
| 공백           | 헤더의 종료. 바디의 시작. 구분 기준                          |
| 바디           | 웹서버로 전달하고자 하는 사용자 데이터 포함<br />(텍스트 뿐만 아니라 바이너리 데이터도 들어갈 수 있다)<br>전송하는 데이터가 없다면 Body는 비어있다. |

- ##### HTTP 응답

| 상태라인 | HTTP/1.1. 200 OK    (HTTP Version/Code:응답상태코드/Phrase:응답상태) |
| -------- | ------------------------------------------------------------ |
| 헤더     | 요청메시지와 동일<br />단, User-Agent 헤더 대신 Server 헤더가 사용 |
| 공백     |                                                              |
| 바디     | 요청메시지와 동일                                            |



## 웹

- #### Servlet과 jsp의 차이

  [참고블로그](https://gmlwjd9405.github.io/2018/11/04/servlet-vs-jsp.html)

  하는 일이 동일하다. 기능의 차이 없이 역할의 차이만 있다.

  > Servlet

  - 웹 기반의 요청에 대한 동적인 처리가 가능한 서버 사이드에서 돌아가는 자바 프로그램
  - JAVA 안에 HTML (하나의 클래스)
  - 웹 개발을 위해 만든 표준

  **Servlet 특징**

  data processing(Controller)에 좋다

  - DB 통신으로 데이터 작업, Business Logic 호출에 유용

  Servlet이 수정된 경우 Java 코드를 컴파일(.class 파일 생성)한 후 동적 페이지 처리하기 때문에 다시 컴파일한 후 재배포하는 작업 필요하다 

  - 개발 생산성 저하

  > JSP

  - 자바 언어를 기반으로 하는 서버 사이드 스크립트 언어
  - HTML 안에 JAVA
  - Servlet을 보완하고 기술을 확장한 스크립트 방식 표준

  **JSP 특징**

  요청 결과를 나타내는 HTML을 작성할 때 유용

  JSP 수정된 경우 컴파일에 따른 재배포가 필요없다. WAS가 자동 처리해준다

  - 배포가 쉽다
  
    

---

- #### jsp의 el과 jstl에 대한 설명

  [참고 블로그](https://gmlwjd9405.github.io/2018/11/03/jsp.html)
  
[참고 블로그](https://doitnow-man.tistory.com/90)
  
> ###### EL (Expression Language)
  
  ```jsp
  <%=variable%>
  ${variable} 		variable -> 변수 or 수식
```
  
  - JSP에서 변수 값을 표현하는데 사용되는 스크립트 언어
  - JSP에서의 기본 문법을 보완하는 역할
  - 자바 클래스 메소드로 가져와야 하는 값을 간편하게 호출할 수 있다
- el의 기본 객체를 제공한다 ex) pageContext, pageScope, param...
  

  
> ###### JSTL (JSP Standard Tag Library)
  
  ```jsp
  <c:if test="${variable}"></c:if>
```
  
**jsp Scriptlet 태그 <% %>** : 복잡한 것을 수행하는 임의의 Java Code를 삽입
  
[문제점] html, java가 섞여 코드가 복잡해진다. 코드의 간결화를 위해 나온 JSTL
  
  - 많은 JSP 애플리케이션의 공통적인 핵심기능을 캡슐화하는 유용한 JSP 태그 라이브러리
  - jsp 개발을 단순화하기 위한 태그 라이브러리
  - jsp 페이지의 조건문, 반복문 처리를 html 태그 형태로 작성할 수 있다
  - 추가적인 jar 파일이 필요







## 데이터베이스

- #### self Join이란 무엇이며 어떤 경우에 사용하는가

  [SELF JOIN 참고](https://tychejin.tistory.com/108)

  **self join**

  - 동일 테이블 사이의 조인

  - FROM 절에 동일 테이블이 두 번 이상 나타남

  - 테이블과 컬럼 이름이 모두 동일하기 때문에 식별을 위해 반드시 별칭(Alias)을 사용

    ```mysql
    SELECT A.NAME AS EMPLOYEE, B.NAME AS MANAGER
    FROM EMP A
    LEFT OUTER JOIN EMP B
    ON A.MGR = B.EMPNO;
    -- 같은 테이블끼리 비교해야하는 경우
    ```

  

  ---

- ##### <u>오라클과 MySQL의 차이에 대해 설명하세요</u> 

  - *오라클이 가격이 비싼만큼 사용자 편의를 위한 기능이 많이 있으며 사용자 실수를 대비, 재해에 대비한 기능, 성능 향상 등 여러 장점이 있다*
  - *MySQL이 더 저렴한 만큼 오라클보다 떨어지는 부분이 많지만 가격대비 성능이 좋다*

  -> **DB 차이를 대신 알아보자**

  ---

  



## 아키텍쳐

- #### REST란 무엇인지, Restful 하게 API를 디자인한다는 것이 무엇인가

  [REST API 참고](https://private.tistory.com/28?category=655782)

  **REST API의 탄생**

  - Representational State Transfer. HTTP의 주요 저자 중 한 사람인 Roy Fielding이 소개. 웹 HTTP 설계의 우수성에 비해 제대로 사용되어지지 못하는 모습에 안타까워 웹의 장점을 최대한 활용할 수 있는 아키텍처로써 REST를 발표

  **REST가 뜨는 이유**

  - Front-End와 Back-End의 분리 시작
    - JSON 형태로 데이터를 제공하는 API 제공
    - RequestMethod(HTTP : GET, POST, PUT, DELETE)와 URL을 이용한 정의
    - View 영역이 포함되지 않은 서버 사이드 개발 진행

  **REST**

  - SOAP(서비스 지향 구조)와 달리 ROA(Resource Oriented Architecture. 자원지향구조)로 웹사이트 컨텐츠(텍스트, 이미지, 영상), 디비 데이터 등을 전부 하나의 자원을 파악하여 각 자원의 고유한 URI(Uniform Resource Identifier)를 부여하고 해당 자원에 대한 CRUD 작업을 HTTP의 기본 명령어인 POST, GET, PUT, DELETE를 통해 처리

  **REST API 디자인**

  - URI는 정보의 자원을 표현해야한다. (리소스명 : 동사보다 명사)
  - 리소스에 대한 행위는 HTTP Method(GET, POST, PUT, DELETE ... )로 표현







## 깃

- #### Git이 무엇인가

  [깃 공식 메뉴얼](https://git-scm.com/book/ko/v2)
  
  [참고 블로그](https://goddaehee.tistory.com/91)

  [버전관리 시스템의 차이 참고 : 중앙집중식 vs 분산](https://ux.stories.pe.kr/78 )
  
- 버전관리시스템 / 형상관리도구(Configuration Management Tool)
    - 파일 변화를 시간에 따라 기록하고 나중에 특정 시점 버전을 다시 꺼내올 수 있는 시스템

  > SVN vs Git

  **SVN** : 중앙집중식 버전 관리 시스템. 온전히 **서버**에서만 버전관리 진행

  **Git** : 분산 버전 관리 시스템. **서버**와 **로컬저장소** 양쪽에서 버전관리가 가능하다

  ex) SVN의 경우 `commit` 명령어를 통해 서버에 로컬 최종본을 저장하지만, Git의 경우 로컬에서 `commit`을 통해 버전관리를 하고  서버에 `push`한다. (Git은 서버와 로컬 저장소에 독립적 commit history를 쌓을 수 있다)

  [SVN과 Git의 차이](https://goddaehee.tistory.com/158)

  > Git

  소스코드를 주고받을 필요 없이 같은 파일을 여러명이 동시에 작업할 수 있다(병렬 개발)

  소스코드가 변경된 이력을 쉽게 확인할 수 있으며 특정시점에서 저장된 버전과 비교하거나 특정 시점으로 되돌아갈 수 있다.
  
  로컬 저장소에 저장이 되어 인터넷이 없는 환경에서도 가능하며 속도가 빠르다



---

- #### Github에서 주로 무엇을 할 수 있는지, 프로젝트에서 깃허브를 사용했을때 어떤 식으로 기여를 했는지 설명하시오

  > Github

  git 웹호스팅 서비스. git 저장소 서버를 대신 유지 및 관리해주는 서비스








## 프레임워크

- #### 프레임워크의 특징과, 프레임워크와 라이브러리의 차이점은 무엇인가

  [프레임워크와 라이브러리의 차이](https://webclub.tistory.com/458)

  > ###### Framework

  - 뼈대.  기반구조
  - 프로그램 구현에 있어서 큰 구조를 결정하고 흐름을 제어하는 역할
  - 사용자는 프레임워크 위에 코드를 짠다
  - 프레임워크가 개발자가 짠 코드를 흐름에 맞게 실행시켜준다

  > ###### Library

  - 단순 활용가능한 도구 모음
  - 자주 쓰는 함수들을 미리 구현해놓고 프로그램에 추가해서 사용한다

  **공통점 **: 간편한 프로그래밍을 도와준다

  **차이점 **: 제어 흐름에 대한 주도권이 어디에 있느냐에 차이가 있다.

  ##### 						"어플리케이션의 Flow(흐름)을 누가 쥐고 있느냐''

  ***프레임워크는 전체적인 흐름을 프로그램이 가지고 있으며 사용자는 필요한 코드를 넣는 반면, 라이브러리는 사용자가 전체적인 흐름을 만들며 라이브러리를 가져다 쓴다.***

  - 프레임워크 주도성 : 프레임워크 (제어의 역전)

    ```
    소스코드 in 프레임워크
    ```

  - 라이브러리 주도성 : 사용자

    ```
    라이브러리 in 소스코드
    ```

##### * 아키텍처?

- 프로그램을 기획할 때 주요 특징을 기술적으로 설계하고 명시하는 것

- 요구사항을 만족하는 시스템을 구축하기 위해 전체 시스템에 대한 구조를 정의한 문서

  

  ---

- #### Spring AOP가 무엇인가

  [Spring AOP 정리 참고](https://shlee0882.tistory.com/206)

  **AOP : Aspect Oriented Programming (관점 지향 프로그래밍)**

  - 애플리케이션 전체에 걸쳐 공통적으로 사용되는 기능을 재사용
  - 핵심 기능과 공통 기능을 분리함으로써 비지니스 로직 개발에 집중해 처리

  **Aspect**

  - Advice : 부가기능을 정의한 코드

  - PointCut : 어드바이스를 어디에 적용할지를 결정

    ###### Aspect = Advice + PointCut

  - 애스펙트는 어드바이스와 포인트컷을 합친 개념

  - 싱글톤 형태의 객체로 존재한다

    

  ---

- #### OOP와 AOP를 비교하여 설명하시오

  OOP : Object Oriented Programming (객체 지향 프로그래밍)

  [AOP 정리 참고](https://jobc.tistory.com/39)

  AOP는 OOP를 더욱 OOP답게 사용할 수 있도록 도와주는 개념으로 볼수 있다

  핵심기능에서 부가기능을 분리함으로써 핵심기능을 설계하고 구현할때 객체지향적인 가치를 지킬 수 있도록 도와주는 개념